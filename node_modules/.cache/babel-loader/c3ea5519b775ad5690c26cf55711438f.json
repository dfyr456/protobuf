{"ast":null,"code":"import JSBI from\"jsbi\";var BIGINT_1=JSBI.BigInt(1);var BIGINT_2=JSBI.BigInt(2);export function interpretAsSignedType(n){// see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n// however, this is a simpler equivalent formula\nvar isEven=JSBI.equal(JSBI.bitwiseAnd(n,JSBI.BigInt(1)),JSBI.BigInt(0));if(isEven){return JSBI.divide(n,BIGINT_2);}else{return JSBI.multiply(JSBI.BigInt(-1),JSBI.divide(JSBI.add(n,BIGINT_1),BIGINT_2));}}export function decodeVarint(buffer,offset){var res=JSBI.BigInt(0);var shift=0;var byte=0;do{if(offset>=buffer.length){throw new RangeError(\"Index out of bound decoding varint\");}byte=buffer[offset++];var multiplier=JSBI.exponentiate(BIGINT_2,JSBI.BigInt(shift));var thisByteValue=JSBI.multiply(JSBI.BigInt(byte&0x7f),multiplier);shift+=7;res=JSBI.add(res,thisByteValue);}while(byte>=0x80);return{value:res,length:shift/7};}","map":{"version":3,"names":["JSBI","BIGINT_1","BigInt","BIGINT_2","interpretAsSignedType","n","isEven","equal","bitwiseAnd","divide","multiply","add","decodeVarint","buffer","offset","res","shift","byte","length","RangeError","multiplier","exponentiate","thisByteValue","value"],"sources":["/Users/afganaskarli/PycharmProjects/protobuf/src/varintUtils.js"],"sourcesContent":["import JSBI from \"jsbi\";\n\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\n\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(\n      JSBI.BigInt(-1),\n      JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2)\n    );\n  }\n}\n\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n\n    byte = buffer[offset++];\n\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n\n  return {\n    value: res,\n    length: shift / 7\n  };\n}\n"],"mappings":"AAAA,MAAO,CAAAA,IAAI,KAAM,MAAM,CAEvB,GAAM,CAAAC,QAAQ,CAAGD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAC/B,GAAM,CAAAC,QAAQ,CAAGH,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAE/B,MAAO,SAAS,CAAAE,qBAAqBA,CAACC,CAAC,CAAE,CACvC;AACA;AACA,GAAM,CAAAC,MAAM,CAAGN,IAAI,CAACO,KAAK,CAACP,IAAI,CAACQ,UAAU,CAACH,CAAC,CAAEL,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAEF,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,CAC7E,GAAII,MAAM,CAAE,CACV,MAAO,CAAAN,IAAI,CAACS,MAAM,CAACJ,CAAC,CAAEF,QAAQ,CAAC,CACjC,CAAC,IAAM,CACL,MAAO,CAAAH,IAAI,CAACU,QAAQ,CAClBV,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,CACfF,IAAI,CAACS,MAAM,CAACT,IAAI,CAACW,GAAG,CAACN,CAAC,CAAEJ,QAAQ,CAAC,CAAEE,QAAQ,CAC7C,CAAC,CACH,CACF,CAEA,MAAO,SAAS,CAAAS,YAAYA,CAACC,MAAM,CAAEC,MAAM,CAAE,CAC3C,GAAI,CAAAC,GAAG,CAAGf,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CACxB,GAAI,CAAAc,KAAK,CAAG,CAAC,CACb,GAAI,CAAAC,IAAI,CAAG,CAAC,CAEZ,EAAG,CACD,GAAIH,MAAM,EAAID,MAAM,CAACK,MAAM,CAAE,CAC3B,KAAM,IAAI,CAAAC,UAAU,CAAC,oCAAoC,CAAC,CAC5D,CAEAF,IAAI,CAAGJ,MAAM,CAACC,MAAM,EAAE,CAAC,CAEvB,GAAM,CAAAM,UAAU,CAAGpB,IAAI,CAACqB,YAAY,CAAClB,QAAQ,CAAEH,IAAI,CAACE,MAAM,CAACc,KAAK,CAAC,CAAC,CAClE,GAAM,CAAAM,aAAa,CAAGtB,IAAI,CAACU,QAAQ,CAACV,IAAI,CAACE,MAAM,CAACe,IAAI,CAAG,IAAI,CAAC,CAAEG,UAAU,CAAC,CACzEJ,KAAK,EAAI,CAAC,CACVD,GAAG,CAAGf,IAAI,CAACW,GAAG,CAACI,GAAG,CAAEO,aAAa,CAAC,CACpC,CAAC,MAAQL,IAAI,EAAI,IAAI,EAErB,MAAO,CACLM,KAAK,CAAER,GAAG,CACVG,MAAM,CAAEF,KAAK,CAAG,CAClB,CAAC,CACH"},"metadata":{},"sourceType":"module"}