{"ast":null,"code":"import { decodeVarint } from \"./varintUtils\";\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n    return result.value;\n  }\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return result;\n  }\n\n  // gRPC has some additional header - remove it\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n    if (length > bytesAvailable) {\n      throw new Error(\"Not enough bytes left. Requested: \" + length + \" left: \" + bytesAvailable);\n    }\n  }\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n}\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  LENDELIM: 2,\n  FIXED32: 5\n};\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n  reader.trySkipGrpcHeader();\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n      const byteRange = [reader.offset];\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n      let value;\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.LENDELIM) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n      byteRange.push(reader.offset);\n      parts.push({\n        byteRange,\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\nexport function typeToString(type, subType) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n    case TYPES.LENDELIM:\n      return subType || \"len_delim\";\n    case TYPES.FIXED32:\n      return \"fixed32\";\n    case TYPES.FIXED64:\n      return \"fixed64\";\n    default:\n      return \"unknown\";\n  }\n}","map":{"version":3,"names":["decodeVarint","BufferReader","constructor","buffer","offset","readVarInt","result","length","value","readBuffer","checkByte","slice","trySkipGrpcHeader","backupOffset","leftBytes","readInt32BE","bytesAvailable","Error","checkpoint","savedOffset","resetToCheckpoint","TYPES","VARINT","FIXED64","LENDELIM","FIXED32","decodeProto","reader","parts","byteRange","indexType","parseInt","toString","type","index","push","err","leftOver","typeToString","subType"],"sources":["/Users/afganaskarli/PycharmProjects/protobuf/src/protobufDecoder.js"],"sourcesContent":["import { decodeVarint } from \"./varintUtils\";\n\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n\n    return result.value;\n  }\n\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n\n    return result;\n  }\n\n  // gRPC has some additional header - remove it\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n    if (length > bytesAvailable) {\n      throw new Error(\n        \"Not enough bytes left. Requested: \" +\n          length +\n          \" left: \" +\n          bytesAvailable\n      );\n    }\n  }\n\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n}\n\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  LENDELIM: 2,\n  FIXED32: 5\n};\n\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n\n  reader.trySkipGrpcHeader();\n\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n\n      const byteRange = [reader.offset];\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n\n      let value;\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.LENDELIM) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n      byteRange.push(reader.offset);\n\n      parts.push({\n        byteRange,\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\n\nexport function typeToString(type, subType) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n    case TYPES.LENDELIM:\n      return subType || \"len_delim\";\n    case TYPES.FIXED32:\n      return \"fixed32\";\n    case TYPES.FIXED64:\n      return \"fixed64\";\n    default:\n      return \"unknown\";\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}