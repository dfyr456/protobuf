{"ast":null,"code":"export function parseInput(input) {\n  const normalizedInput = input.replace(/\\s/g, \"\");\n  const normalizedHexInput = normalizedInput.replace(/0x/g, \"\").toLowerCase();\n  if (isHex(normalizedHexInput)) {\n    return Buffer.from(normalizedHexInput, \"hex\");\n  } else {\n    return Buffer.from(normalizedInput, \"base64\");\n  }\n}\nexport function isHex(string) {\n  let result = true;\n  for (const char of string) {\n    if (!(char >= \"a\" && char <= \"f\" || char >= \"0\" && char <= \"9\")) {\n      result = false;\n    }\n  }\n  return result;\n}\nexport function bufferToPrettyHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    if (output !== \"\") {\n      output += \" \";\n    }\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output += \"0\" + hex;\n    } else {\n      output += hex;\n    }\n  }\n  return output;\n}\nexport function bufferLeToBeHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output = \"0\" + hex + output;\n    } else {\n      output = hex + output;\n    }\n  }\n  return output;\n}","map":{"version":3,"names":["parseInput","input","normalizedInput","replace","normalizedHexInput","toLowerCase","isHex","Buffer","from","string","result","char","bufferToPrettyHex","buffer","output","v","hex","toString","length","bufferLeToBeHex"],"sources":["/Users/afganaskarli/PycharmProjects/protobuf/src/hexUtils.js"],"sourcesContent":["export function parseInput(input) {\n  const normalizedInput = input.replace(/\\s/g, \"\");\n  const normalizedHexInput = normalizedInput.replace(/0x/g, \"\").toLowerCase();\n  if (isHex(normalizedHexInput)) {\n    return Buffer.from(normalizedHexInput, \"hex\");\n  } else {\n    return Buffer.from(normalizedInput, \"base64\");\n  }\n}\n\nexport function isHex(string) {\n  let result = true;\n  for (const char of string) {\n    if (!((char >= \"a\" && char <= \"f\") || (char >= \"0\" && char <= \"9\"))) {\n      result = false;\n    }\n  }\n  return result;\n}\n\nexport function bufferToPrettyHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    if (output !== \"\") {\n      output += \" \";\n    }\n\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output += \"0\" + hex;\n    } else {\n      output += hex;\n    }\n  }\n  return output;\n}\n\nexport function bufferLeToBeHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output = \"0\" + hex + output;\n    } else {\n      output = hex + output;\n    }\n  }\n  return output;\n}\n"],"mappings":"AAAA,OAAO,SAASA,UAAUA,CAACC,KAAK,EAAE;EAChC,MAAMC,eAAe,GAAGD,KAAK,CAACE,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;EAChD,MAAMC,kBAAkB,GAAGF,eAAe,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACE,WAAW,CAAC,CAAC;EAC3E,IAAIC,KAAK,CAACF,kBAAkB,CAAC,EAAE;IAC7B,OAAOG,MAAM,CAACC,IAAI,CAACJ,kBAAkB,EAAE,KAAK,CAAC;EAC/C,CAAC,MAAM;IACL,OAAOG,MAAM,CAACC,IAAI,CAACN,eAAe,EAAE,QAAQ,CAAC;EAC/C;AACF;AAEA,OAAO,SAASI,KAAKA,CAACG,MAAM,EAAE;EAC5B,IAAIC,MAAM,GAAG,IAAI;EACjB,KAAK,MAAMC,IAAI,IAAIF,MAAM,EAAE;IACzB,IAAI,EAAGE,IAAI,IAAI,GAAG,IAAIA,IAAI,IAAI,GAAG,IAAMA,IAAI,IAAI,GAAG,IAAIA,IAAI,IAAI,GAAI,CAAC,EAAE;MACnED,MAAM,GAAG,KAAK;IAChB;EACF;EACA,OAAOA,MAAM;AACf;AAEA,OAAO,SAASE,iBAAiBA,CAACC,MAAM,EAAE;EACxC,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,MAAMC,CAAC,IAAIF,MAAM,EAAE;IACtB,IAAIC,MAAM,KAAK,EAAE,EAAE;MACjBA,MAAM,IAAI,GAAG;IACf;IAEA,MAAME,GAAG,GAAGD,CAAC,CAACE,QAAQ,CAAC,EAAE,CAAC;IAC1B,IAAID,GAAG,CAACE,MAAM,KAAK,CAAC,EAAE;MACpBJ,MAAM,IAAI,GAAG,GAAGE,GAAG;IACrB,CAAC,MAAM;MACLF,MAAM,IAAIE,GAAG;IACf;EACF;EACA,OAAOF,MAAM;AACf;AAEA,OAAO,SAASK,eAAeA,CAACN,MAAM,EAAE;EACtC,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,MAAMC,CAAC,IAAIF,MAAM,EAAE;IACtB,MAAMG,GAAG,GAAGD,CAAC,CAACE,QAAQ,CAAC,EAAE,CAAC;IAC1B,IAAID,GAAG,CAACE,MAAM,KAAK,CAAC,EAAE;MACpBJ,MAAM,GAAG,GAAG,GAAGE,GAAG,GAAGF,MAAM;IAC7B,CAAC,MAAM;MACLA,MAAM,GAAGE,GAAG,GAAGF,MAAM;IACvB;EACF;EACA,OAAOA,MAAM;AACf"},"metadata":{},"sourceType":"module"}