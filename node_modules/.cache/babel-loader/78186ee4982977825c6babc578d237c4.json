{"ast":null,"code":"import JSBI from \"jsbi\";\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(JSBI.BigInt(-1), JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2));\n  }\n}\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n    byte = buffer[offset++];\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n  return {\n    value: res,\n    length: shift / 7\n  };\n}","map":{"version":3,"names":["JSBI","BIGINT_1","BigInt","BIGINT_2","interpretAsSignedType","n","isEven","equal","bitwiseAnd","divide","multiply","add","decodeVarint","buffer","offset","res","shift","byte","length","RangeError","multiplier","exponentiate","thisByteValue","value"],"sources":["/Users/afganaskarli/PycharmProjects/protobuf/src/varintUtils.js"],"sourcesContent":["import JSBI from \"jsbi\";\n\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\n\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(\n      JSBI.BigInt(-1),\n      JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2)\n    );\n  }\n}\n\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n\n    byte = buffer[offset++];\n\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n\n  return {\n    value: res,\n    length: shift / 7\n  };\n}\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,MAAM;AAEvB,MAAMC,QAAQ,GAAGD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC;AAC/B,MAAMC,QAAQ,GAAGH,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC;AAE/B,OAAO,SAASE,qBAAqBA,CAACC,CAAC,EAAE;EACvC;EACA;EACA,MAAMC,MAAM,GAAGN,IAAI,CAACO,KAAK,CAACP,IAAI,CAACQ,UAAU,CAACH,CAAC,EAAEL,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEF,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC;EAC7E,IAAII,MAAM,EAAE;IACV,OAAON,IAAI,CAACS,MAAM,CAACJ,CAAC,EAAEF,QAAQ,CAAC;EACjC,CAAC,MAAM;IACL,OAAOH,IAAI,CAACU,QAAQ,CAClBV,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,EACfF,IAAI,CAACS,MAAM,CAACT,IAAI,CAACW,GAAG,CAACN,CAAC,EAAEJ,QAAQ,CAAC,EAAEE,QAAQ,CAC7C,CAAC;EACH;AACF;AAEA,OAAO,SAASS,YAAYA,CAACC,MAAM,EAAEC,MAAM,EAAE;EAC3C,IAAIC,GAAG,GAAGf,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC;EACxB,IAAIc,KAAK,GAAG,CAAC;EACb,IAAIC,IAAI,GAAG,CAAC;EAEZ,GAAG;IACD,IAAIH,MAAM,IAAID,MAAM,CAACK,MAAM,EAAE;MAC3B,MAAM,IAAIC,UAAU,CAAC,oCAAoC,CAAC;IAC5D;IAEAF,IAAI,GAAGJ,MAAM,CAACC,MAAM,EAAE,CAAC;IAEvB,MAAMM,UAAU,GAAGpB,IAAI,CAACqB,YAAY,CAAClB,QAAQ,EAAEH,IAAI,CAACE,MAAM,CAACc,KAAK,CAAC,CAAC;IAClE,MAAMM,aAAa,GAAGtB,IAAI,CAACU,QAAQ,CAACV,IAAI,CAACE,MAAM,CAACe,IAAI,GAAG,IAAI,CAAC,EAAEG,UAAU,CAAC;IACzEJ,KAAK,IAAI,CAAC;IACVD,GAAG,GAAGf,IAAI,CAACW,GAAG,CAACI,GAAG,EAAEO,aAAa,CAAC;EACpC,CAAC,QAAQL,IAAI,IAAI,IAAI;EAErB,OAAO;IACLM,KAAK,EAAER,GAAG;IACVG,MAAM,EAAEF,KAAK,GAAG;EAClB,CAAC;AACH"},"metadata":{},"sourceType":"module"}