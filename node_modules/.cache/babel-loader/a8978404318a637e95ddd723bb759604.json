{"ast":null,"code":"import _classCallCheck from\"/Users/afganaskarli/PycharmProjects/protobuf/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/afganaskarli/PycharmProjects/protobuf/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import{decodeVarint}from\"./varintUtils\";var BufferReader=/*#__PURE__*/function(){function BufferReader(buffer){_classCallCheck(this,BufferReader);this.buffer=buffer;this.offset=0;}_createClass(BufferReader,[{key:\"readVarInt\",value:function readVarInt(){var result=decodeVarint(this.buffer,this.offset);this.offset+=result.length;return result.value;}},{key:\"readBuffer\",value:function readBuffer(length){this.checkByte(length);var result=this.buffer.slice(this.offset,this.offset+length);this.offset+=length;return result;}// gRPC has some additional header - remove it\n},{key:\"trySkipGrpcHeader\",value:function trySkipGrpcHeader(){var backupOffset=this.offset;if(this.buffer[this.offset]===0&&this.leftBytes()>=5){this.offset++;var length=this.buffer.readInt32BE(this.offset);this.offset+=4;if(length>this.leftBytes()){// Something is wrong, revert\nthis.offset=backupOffset;}}}},{key:\"leftBytes\",value:function leftBytes(){return this.buffer.length-this.offset;}},{key:\"checkByte\",value:function checkByte(length){var bytesAvailable=this.leftBytes();if(length>bytesAvailable){throw new Error(\"Not enough bytes left. Requested: \"+length+\" left: \"+bytesAvailable);}}},{key:\"checkpoint\",value:function checkpoint(){this.savedOffset=this.offset;}},{key:\"resetToCheckpoint\",value:function resetToCheckpoint(){this.offset=this.savedOffset;}}]);return BufferReader;}();export var TYPES={VARINT:0,FIXED64:1,LENDELIM:2,FIXED32:5};export function decodeProto(buffer){var reader=new BufferReader(buffer);var parts=[];reader.trySkipGrpcHeader();try{while(reader.leftBytes()>0){reader.checkpoint();var byteRange=[reader.offset];var indexType=parseInt(reader.readVarInt().toString());var type=indexType&7;var index=indexType>>3;var value=void 0;if(type===TYPES.VARINT){value=reader.readVarInt().toString();}else if(type===TYPES.LENDELIM){var length=parseInt(reader.readVarInt().toString());value=reader.readBuffer(length);}else if(type===TYPES.FIXED32){value=reader.readBuffer(4);}else if(type===TYPES.FIXED64){value=reader.readBuffer(8);}else{throw new Error(\"Unknown type: \"+type);}byteRange.push(reader.offset);parts.push({byteRange:byteRange,index:index,type:type,value:value});}}catch(err){reader.resetToCheckpoint();}return{parts:parts,leftOver:reader.readBuffer(reader.leftBytes())};}export function typeToString(type,subType){switch(type){case TYPES.VARINT:return\"varint\";case TYPES.LENDELIM:return subType||\"len_delim\";case TYPES.FIXED32:return\"fixed32\";case TYPES.FIXED64:return\"fixed64\";default:return\"unknown\";}}","map":{"version":3,"names":["decodeVarint","BufferReader","buffer","_classCallCheck","offset","_createClass","key","value","readVarInt","result","length","readBuffer","checkByte","slice","trySkipGrpcHeader","backupOffset","leftBytes","readInt32BE","bytesAvailable","Error","checkpoint","savedOffset","resetToCheckpoint","TYPES","VARINT","FIXED64","LENDELIM","FIXED32","decodeProto","reader","parts","byteRange","indexType","parseInt","toString","type","index","push","err","leftOver","typeToString","subType"],"sources":["/Users/afganaskarli/PycharmProjects/protobuf/src/protobufDecoder.js"],"sourcesContent":["import { decodeVarint } from \"./varintUtils\";\n\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n\n    return result.value;\n  }\n\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n\n    return result;\n  }\n\n  // gRPC has some additional header - remove it\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n    if (length > bytesAvailable) {\n      throw new Error(\n        \"Not enough bytes left. Requested: \" +\n          length +\n          \" left: \" +\n          bytesAvailable\n      );\n    }\n  }\n\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n}\n\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  LENDELIM: 2,\n  FIXED32: 5\n};\n\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n\n  reader.trySkipGrpcHeader();\n\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n\n      const byteRange = [reader.offset];\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n\n      let value;\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.LENDELIM) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n      byteRange.push(reader.offset);\n\n      parts.push({\n        byteRange,\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\n\nexport function typeToString(type, subType) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n    case TYPES.LENDELIM:\n      return subType || \"len_delim\";\n    case TYPES.FIXED32:\n      return \"fixed32\";\n    case TYPES.FIXED64:\n      return \"fixed64\";\n    default:\n      return \"unknown\";\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}