{"version":3,"sources":["varintUtils.js","protobufDecoder.js","protobufPartDecoder.js","ProtobufPart.js","ProtobufDisplay.js","App.js","index.js","hexUtils.js"],"names":["BIGINT_2","JSBI","BigInt","BufferReader","buffer","_classCallCheck","this","offset","_createClass","key","value","result","res","shift","byte","length","RangeError","multiplier","exponentiate","thisByteValue","multiply","add","decodeVarint","checkByte","slice","backupOffset","leftBytes","readInt32BE","bytesAvailable","Error","savedOffset","TYPES","decodeProto","reader","parts","trySkipGrpcHeader","checkpoint","byteRange","indexType","parseInt","readVarInt","toString","type","index","readBuffer","push","err","resetToCheckpoint","leftOver","ProtobufVarintPart","props","intVal","decodeVarintParts","map","d","i","filter","x","getProtobufPart","part","React","createElement","decoded","ProtobufDisplay","td","TextDecoder","fatal","decode","e","bufferToPrettyHex","decodeStringOrBytes","ProtobufPart","_getProtobufPart","_slicedToArray","Fragment","App","_useState","useState","_useState2","setHex","_useState3","_useState4","hexBuffer","setHexBuffer","location","useLocation","useEffect","pathname","newHex","decodeURI","substr","parseInput","ReactDOM","render","Router","document","getElementById","input","normalizedInput","replace","normalizedHexInput","toLowerCase","string","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","char","return","isHex","Buffer","from","output","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","v","hex","bufferLeToBeHex","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3"],"mappings":"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","file":"static/js/main.86afd43c.chunk.js","sourcesContent":["import JSBI from \"jsbi\";\n\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\n\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(\n      JSBI.BigInt(-1),\n      JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2)\n    );\n  }\n}\n\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n\n    byte = buffer[offset++];\n\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n\n  return {\n    value: res,\n    length: shift / 7\n  };\n}\n","import { decodeVarint } from \"./varintUtils\";\n\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n\n    return result.value;\n  }\n\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n\n    return result;\n  }\n\n  // gRPC has some additional header - remove it\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n    if (length > bytesAvailable) {\n      throw new Error(\n        \"Not enough bytes left. Requested: \" +\n          length +\n          \" left: \" +\n          bytesAvailable\n      );\n    }\n  }\n\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n}\n\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  LENDELIM: 2,\n  FIXED32: 5\n};\n\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n\n  reader.trySkipGrpcHeader();\n\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n\n      const byteRange = [reader.offset];\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n\n      let value;\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.LENDELIM) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n      byteRange.push(reader.offset);\n\n      parts.push({\n        byteRange,\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\n\nexport function typeToString(type, subType) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n    case TYPES.LENDELIM:\n      return subType || \"len_delim\";\n    case TYPES.FIXED32:\n      return \"fixed32\";\n    case TYPES.FIXED64:\n      return \"fixed64\";\n    default:\n      return \"unknown\";\n  }\n}\n","import JSBI from \"jsbi\";\nimport { bufferLeToBeHex, bufferToPrettyHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\n\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue });\n  }\n\n  result.push({ type: \"Float\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue.toString() });\n\n\n  return result;\n}\n\n\n// this is also related\n\nexport function decodeVarintParts(value) {\n  const result = [];\n  const intVal = JSBI.BigInt(value);\n  result.push({  value: intVal.toString() });\n\n\n  return result;\n}\n\nexport function decodeStringOrBytes(value) {\n  if (!value.length) {\n    return { type: \"string|bytes\", value: \"\" };\n  }\n  const td = new TextDecoder(\"utf-8\", { fatal: true });\n  try {\n    return { type: \"string\", value: td.decode(value) };\n  } catch (e) {\n    return { type: \"bytes\", value: bufferToPrettyHex(value) };\n  }\n}\n\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}\n","import React from \"react\";\nimport { Table } from \"semantic-ui-react\";\nimport { decodeProto, TYPES, typeToString } from \"./protobufDecoder\";\nimport {\n\n\n  decodeStringOrBytes,\n  decodeVarintParts\n} from \"./protobufPartDecoder\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\n\n\n\nfunction ProtobufVarintPart(props) {\n  const { value } = props;\n  const decoded = decodeVarintParts(value);\n  // this is what we are looking for:\n  return decoded.map((d, i) => {\n    return i === 0 ? d.value : null;\n  }).filter(x => x);\n}\n\n\n\n\n\n\nfunction getProtobufPart(part) {\n  switch (part.type) {\n    case TYPES.VARINT:\n      return [<ProtobufVarintPart value={part.value} />];\n    case TYPES.LENDELIM:\n      // TODO: Support repeated field\n\n\n      let decoded = decodeProto(part.value);\n\n\n      if (part.value.length > 0 && decoded.leftOver.length === 0) {\n        return [<ProtobufDisplay value={decoded} />];\n      } else {\n        decoded = decodeStringOrBytes(part.value);\n        return \"\";\n      }\n\n\n  }\n}\n\nfunction ProtobufPart(props) {\n  const { part } = props;\n\n  const [contents] = getProtobufPart(part);\n\n\nreturn (\n  contents\n);\n}\n\nexport default ProtobufPart;\n","import React, { Fragment } from \"react\";\nimport ProtobufPart from \"./ProtobufPart\";\nimport { Table } from \"semantic-ui-react\";\nimport { bufferToPrettyHex } from \"./hexUtils\";\n\nfunction ProtobufDisplay(props) {\n  const { value } = props;\n\n  const parts = value.parts.map((part, i) => {\n  return i === 0 ? <ProtobufPart key={i} part={part} /> : null;\n}).filter(x => x);\n\n\n\nreturn (\n  <Fragment>\n    {parts}\n  </Fragment>\n);\n}\n\nexport default ProtobufDisplay;\n","import React, { Fragment, useState, useEffect } from \"react\";\nimport { Container, Divider, TextArea } from \"semantic-ui-react\";\nimport { useLocation } from 'react-router-dom';\nimport { parseInput, bufferToPrettyHex } from \"./hexUtils\";\nimport \"./App.css\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\nimport { decodeProto } from \"./protobufDecoder\";\n\nfunction App() {\n  const [hex, setHex] = useState(\"\");\n  const [hexBuffer, setHexBuffer] = useState(\"\");\n  const location = useLocation();\n  const onHexChanged = e => {\n    setHex(e.target.value);\n  };\n\n  const onSubmit = () => {\n    const buffer = parseInput(hex);\n    setHex(bufferToPrettyHex(buffer));\n    setHexBuffer(buffer);\n  };\n\n  useEffect(() => {\n    if (location.pathname !== '/') {\n      const newHex = decodeURI(location.pathname.substr(1));\n      setHex(newHex);\n\n      // Parsing and decoding\n      const buffer = parseInput(newHex);\n      setHex(bufferToPrettyHex(buffer));\n      setHexBuffer(buffer);\n    }\n  }, [location.pathname]);\n\n\n  const result = hexBuffer ? (\n\n\n      <ProtobufDisplay value={decodeProto(hexBuffer)} />\n\n  ) : null;\n\n  return (\n    <Fragment>\n\n\n\n      {result}\n\n    </Fragment>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport App from \"./App\";\nimport \"semantic-ui-css/semantic.min.css\";\n\nReactDOM.render(\n  <Router>\n    <App />\n  </Router>,\n  document.getElementById(\"root\")\n);","export function parseInput(input) {\n  const normalizedInput = input.replace(/\\s/g, \"\");\n  const normalizedHexInput = normalizedInput.replace(/0x/g, \"\").toLowerCase();\n  if (isHex(normalizedHexInput)) {\n    return Buffer.from(normalizedHexInput, \"hex\");\n  } else {\n    return Buffer.from(normalizedInput, \"base64\");\n  }\n}\n\nexport function isHex(string) {\n  let result = true;\n  for (const char of string) {\n    if (!((char >= \"a\" && char <= \"f\") || (char >= \"0\" && char <= \"9\"))) {\n      result = false;\n    }\n  }\n  return result;\n}\n\nexport function bufferToPrettyHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    if (output !== \"\") {\n      output += \" \";\n    }\n\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output += \"0\" + hex;\n    } else {\n      output += hex;\n    }\n  }\n  return output;\n}\n\nexport function bufferLeToBeHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output = \"0\" + hex + output;\n    } else {\n      output = hex + output;\n    }\n  }\n  return output;\n}\n"],"sourceRoot":""}