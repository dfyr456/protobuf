{"version":3,"sources":["hexUtils.js","varintUtils.js","protobufDecoder.js","protobufPartDecoder.js","ProtobufPart.js","ProtobufDisplay.js","App.js","index.js"],"names":["parseInput","input","normalizedInput","replace","normalizedHexInput","toLowerCase","string","result","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","char","value","err","return","isHex","Buffer","from","bufferToPrettyHex","buffer","output","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","v","hex","toString","length","bufferLeToBeHex","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","BIGINT_2","JSBI","BigInt","BufferReader","_classCallCheck","this","offset","_createClass","key","res","shift","byte","RangeError","multiplier","exponentiate","thisByteValue","multiply","add","decodeVarint","checkByte","slice","backupOffset","leftBytes","readInt32BE","bytesAvailable","Error","savedOffset","TYPES","decodeProto","reader","parts","trySkipGrpcHeader","checkpoint","byteRange","indexType","parseInt","readVarInt","type","index","readBuffer","push","resetToCheckpoint","leftOver","ProtobufVarintPart","props","intVal","decodeVarintParts","map","d","i","filter","x","getProtobufPart","part","React","createElement","decoded","ProtobufDisplay","td","TextDecoder","fatal","decode","e","decodeStringOrBytes","ProtobufPart","_getProtobufPart","_slicedToArray","Fragment","App","_useState","useState","_useState2","hexBuffer","setHexBuffer","location","useLocation","useEffect","pathname","newHex","decodeURI","substr","ReactDOM","render","Router","document","getElementById"],"mappings":"gIAAA,YAAO,SAASA,EAAWC,GACzB,IAAMC,EAAkBD,EAAME,QAAQ,MAAO,IACvCC,EAAqBF,EAAgBC,QAAQ,MAAO,IAAIE,cAC9D,OAOK,SAAeC,GACpB,IAAIC,GAAS,EAAKC,GAAA,EAAAC,GAAA,EAAAC,OAAAC,EAAA,IAClB,QAAyBC,EAAzBC,EAAmBP,EAAMQ,OAAAC,cAAAP,GAAAI,EAAAC,EAAAG,QAAAC,MAAAT,GAAA,EAAE,CAAC,IAAjBU,EAAIN,EAAAO,MACND,GAAQ,KAAOA,GAAQ,KAASA,GAAQ,KAAOA,GAAQ,MAC5DX,GAAS,IAEZ,MAAAa,GAAAX,GAAA,EAAAC,EAAAU,EAAA,YAAAZ,GAAA,MAAAK,EAAAQ,QAAAR,EAAAQ,SAAA,WAAAZ,EAAA,MAAAC,GACD,OAAOH,EAdHe,CAAMlB,GACDmB,EAAOC,KAAKpB,EAAoB,OAEhCmB,EAAOC,KAAKtB,EAAiB,UAcjC,SAASuB,EAAkBC,GAChC,IAAIC,EAAS,GAAGC,GAAA,EAAAC,GAAA,EAAAC,OAAAnB,EAAA,IAChB,QAAsBoB,EAAtBC,EAAgBN,EAAMZ,OAAAC,cAAAa,GAAAG,EAAAC,EAAAhB,QAAAC,MAAAW,GAAA,EAAE,CAAC,IAAdK,EAACF,EAAAZ,MACK,KAAXQ,IACFA,GAAU,KAGZ,IAAMO,EAAMD,EAAEE,SAAS,IACJ,IAAfD,EAAIE,OACNT,GAAU,IAAMO,EAEhBP,GAAUO,GAEb,MAAAd,GAAAS,GAAA,EAAAC,EAAAV,EAAA,YAAAQ,GAAA,MAAAI,EAAAX,QAAAW,EAAAX,SAAA,WAAAQ,EAAA,MAAAC,GACD,OAAOH,EAGF,SAASU,EAAgBX,GAC9B,IAAIC,EAAS,GAAGW,GAAA,EAAAC,GAAA,EAAAC,OAAA7B,EAAA,IAChB,QAAsB8B,EAAtBC,EAAgBhB,EAAMZ,OAAAC,cAAAuB,GAAAG,EAAAC,EAAA1B,QAAAC,MAAAqB,GAAA,EAAE,CAAC,IACjBJ,EADIO,EAAAtB,MACIgB,SAAS,IAErBR,EADiB,IAAfO,EAAIE,OACG,IAAMF,EAAMP,EAEZO,EAAMP,GAElB,MAAAP,GAAAmB,GAAA,EAAAC,EAAApB,EAAA,YAAAkB,GAAA,MAAAI,EAAArB,QAAAqB,EAAArB,SAAA,WAAAkB,EAAA,MAAAC,GACD,OAAOb,EA/CT,wG,kOCGMgB,GADWC,IAAKC,OAAO,GACZD,IAAKC,OAAO,ICHgB,IAEvCC,EAAY,WAChB,SAAAA,EAAYpB,GAAQqB,YAAA,KAAAD,GAClBE,KAAKtB,OAASA,EACdsB,KAAKC,OAAS,EAwDf,OAvDAC,YAAAJ,EAAA,EAAAK,IAAA,aAAAhC,MAAA,WAGC,IAAMZ,EDUH,SAAsBmB,EAAQuB,GACnC,IAAIG,EAAMR,IAAKC,OAAO,GAClBQ,EAAQ,EACRC,EAAO,EAEX,EAAG,CACD,GAAIL,GAAUvB,EAAOU,OACnB,MAAM,IAAImB,WAAW,sCAGvBD,EAAO5B,EAAOuB,KAEd,IAAMO,EAAaZ,IAAKa,aAAad,EAAUC,IAAKC,OAAOQ,IACrDK,EAAgBd,IAAKe,SAASf,IAAKC,OAAc,IAAPS,GAAcE,GAC9DH,GAAS,EACTD,EAAMR,IAAKgB,IAAIR,EAAKM,SACbJ,GAAQ,KAEjB,MAAO,CACLnC,MAAOiC,EACPhB,OAAQiB,EAAQ,GC9BDQ,CAAab,KAAKtB,OAAQsB,KAAKC,QAG9C,OAFAD,KAAKC,QAAU1C,EAAO6B,OAEf7B,EAAOY,QACf,CAAAgC,IAAA,aAAAhC,MAAA,SAEUiB,GACTY,KAAKc,UAAU1B,GACf,IAAM7B,EAASyC,KAAKtB,OAAOqC,MAAMf,KAAKC,OAAQD,KAAKC,OAASb,GAG5D,OAFAY,KAAKC,QAAUb,EAER7B,IAGT,CAAA4C,IAAA,oBAAAhC,MAAA,WAEE,IAAM6C,EAAehB,KAAKC,OAE1B,GAAiC,IAA7BD,KAAKtB,OAAOsB,KAAKC,SAAiBD,KAAKiB,aAAe,EAAG,CAC3DjB,KAAKC,SACL,IAAMb,EAASY,KAAKtB,OAAOwC,YAAYlB,KAAKC,QAC5CD,KAAKC,QAAU,EAEXb,EAASY,KAAKiB,cAEhBjB,KAAKC,OAASe,MAGnB,CAAAb,IAAA,YAAAhC,MAAA,WAGC,OAAO6B,KAAKtB,OAAOU,OAASY,KAAKC,SAClC,CAAAE,IAAA,YAAAhC,MAAA,SAESiB,GACR,IAAM+B,EAAiBnB,KAAKiB,YAC5B,GAAI7B,EAAS+B,EACX,MAAM,IAAIC,MACR,qCACEhC,EACA,UACA+B,KAGP,CAAAhB,IAAA,aAAAhC,MAAA,WAGC6B,KAAKqB,YAAcrB,KAAKC,SACzB,CAAAE,IAAA,oBAAAhC,MAAA,WAGC6B,KAAKC,OAASD,KAAKqB,gBACpBvB,EA3De,GA8DLwB,EACH,EADGA,EAEF,EAFEA,EAGD,EAHCA,EAIF,EAGJ,SAASC,EAAY7C,GAC1B,IAAM8C,EAAS,IAAI1B,EAAapB,GAC1B+C,EAAQ,GAEdD,EAAOE,oBAEP,IACE,KAAOF,EAAOP,YAAc,GAAG,CAC7BO,EAAOG,aAEP,IAAMC,EAAY,CAACJ,EAAOvB,QACpB4B,EAAYC,SAASN,EAAOO,aAAa5C,YACzC6C,EAAmB,EAAZH,EACPI,EAAQJ,GAAa,EAEvB1D,OAAK,EACT,GAAI6D,IAASV,EACXnD,EAAQqD,EAAOO,aAAa5C,gBACvB,GAAI6C,IAASV,EAAgB,CAClC,IAAMlC,EAAS0C,SAASN,EAAOO,aAAa5C,YAC5ChB,EAAQqD,EAAOU,WAAW9C,QACrB,GAAI4C,IAASV,EAClBnD,EAAQqD,EAAOU,WAAW,OACrB,IAAIF,IAASV,EAGlB,MAAM,IAAIF,MAAM,iBAAmBY,GAFnC7D,EAAQqD,EAAOU,WAAW,GAI5BN,EAAUO,KAAKX,EAAOvB,QAEtBwB,EAAMU,KAAK,CACTP,YACAK,QACAD,OACA7D,WAGJ,MAAOC,GACPoD,EAAOY,oBAGT,MAAO,CACLX,QACAY,SAAUb,EAAOU,WAAWV,EAAOP,cCvDvBrB,IAAKC,OAAO,sBACFD,IAAKC,OAAO,uBC/CtC,SAASyC,EAAmBC,GAI1B,ODqBK,SAA2BpE,GAChC,IAAMZ,EAAS,GACTiF,EAAS5C,IAAKC,OAAO1B,GAI3B,OAHAZ,EAAO4E,KAAK,CAAGhE,MAAOqE,EAAOrD,aAGtB5B,EC7BSkF,CADEF,EAAVpE,OAGOuE,KAAI,SAACC,EAAGC,GACrB,OAAa,IAANA,EAAUD,EAAExE,MAAQ,QAC1B0E,QAAO,SAAAC,GAAC,OAAIA,KAQjB,SAASC,EAAgBC,GAEvB,OAAQA,EAAKhB,MACX,KAAKV,EACH,MAAO,CAAC2B,IAAAC,cAACZ,EAAkB,CAACnE,MAAO6E,EAAK7E,SAC1C,KAAKmD,EAIH,IAAI6B,EAAU5B,EAAYyB,EAAK7E,OAG/B,OAAI6E,EAAK7E,MAAMiB,OAAS,GAAiC,IAA5B+D,EAAQd,SAASjD,OACrC,CAAC6D,IAAAC,cAACE,EAAe,CAACjF,MAAOgF,MAEhCA,EDKD,SAA6BhF,GAClC,IAAKA,EAAMiB,OACT,MAAO,CAAE4C,KAAM,eAAgB7D,MAAO,IAExC,IAAMkF,EAAK,IAAIC,YAAY,QAAS,CAAEC,OAAO,IAC7C,IACE,MAAO,CAAEvB,KAAM,SAAU7D,MAAOkF,EAAGG,OAAOrF,IAC1C,MAAOsF,GACP,MAAO,CAAEzB,KAAM,QAAS7D,MAAOM,YAAkBN,KCbnCuF,CAAoBV,EAAK7E,OAC5B,KAkBAwF,MAXf,SAAsBpB,GAAQ,IAChBqB,EAEOb,EAFFR,EAATS,MAKV,OAH0Ca,YAAAD,EAAA,GAAzB,IChCFR,MAhBf,SAAyBb,GAAQ,IAGzBd,EAFYc,EAAVpE,MAEYsD,MAAMiB,KAAI,SAACM,EAAMJ,GACrC,OAAa,IAANA,EAAUK,IAAAC,cAACS,EAAY,CAACxD,IAAKyC,EAAGI,KAAMA,IAAW,QACvDH,QAAO,SAAAC,GAAC,OAAIA,KAIf,OACEG,IAAAC,cAACY,WAAQ,KACNrC,IC+BUsC,MAvCf,WAAgB,IAADC,EAEqBC,mBAAS,IAAGC,EAAAL,YAAAG,EAAA,GAAvCG,EAASD,EAAA,GAAEE,EAAYF,EAAA,GACxBG,EAAWC,cAKjBC,qBAAU,WACR,GAA0B,MAAtBF,EAASG,SAAkB,CAC7B,IAAMC,EAASC,UAAUL,EAASG,SAASG,OAAO,IAI5CjG,EAAS1B,YAAWyH,GAE1BL,EAAa1F,MAEd,CAAC2F,EAASG,WAGb,IAAMjH,EAAS4G,EAGXlB,IAAAC,cAACE,EAAe,CAACjF,MAAOoD,EAAY4C,KAEpC,KAEJ,OACElB,IAAAC,cAACY,WAAQ,KAINvG,I,MCnCPqH,IAASC,OACP5B,IAAAC,cAAC4B,IAAM,KACL7B,IAAAC,cAACa,EAAG,OAENgB,SAASC,eAAe,W","file":"static/js/main.ca8628fb.chunk.js","sourcesContent":["export function parseInput(input) {\n  const normalizedInput = input.replace(/\\s/g, \"\");\n  const normalizedHexInput = normalizedInput.replace(/0x/g, \"\").toLowerCase();\n  if (isHex(normalizedHexInput)) {\n    return Buffer.from(normalizedHexInput, \"hex\");\n  } else {\n    return Buffer.from(normalizedInput, \"base64\");\n  }\n}\n\nexport function isHex(string) {\n  let result = true;\n  for (const char of string) {\n    if (!((char >= \"a\" && char <= \"f\") || (char >= \"0\" && char <= \"9\"))) {\n      result = false;\n    }\n  }\n  return result;\n}\n\nexport function bufferToPrettyHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    if (output !== \"\") {\n      output += \" \";\n    }\n\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output += \"0\" + hex;\n    } else {\n      output += hex;\n    }\n  }\n  return output;\n}\n\nexport function bufferLeToBeHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output = \"0\" + hex + output;\n    } else {\n      output = hex + output;\n    }\n  }\n  return output;\n}\n","import JSBI from \"jsbi\";\n\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\n\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(\n      JSBI.BigInt(-1),\n      JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2)\n    );\n  }\n}\n\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n\n    byte = buffer[offset++];\n\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n\n  return {\n    value: res,\n    length: shift / 7\n  };\n}\n","import { decodeVarint } from \"./varintUtils\";\n\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n\n    return result.value;\n  }\n\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n\n    return result;\n  }\n\n  // gRPC has some additional header - remove it\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n    if (length > bytesAvailable) {\n      throw new Error(\n        \"Not enough bytes left. Requested: \" +\n          length +\n          \" left: \" +\n          bytesAvailable\n      );\n    }\n  }\n\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n}\n\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  LENDELIM: 2,\n  FIXED32: 5\n};\n\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n\n  reader.trySkipGrpcHeader();\n\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n\n      const byteRange = [reader.offset];\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n\n      let value;\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.LENDELIM) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n      byteRange.push(reader.offset);\n\n      parts.push({\n        byteRange,\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\n\nexport function typeToString(type, subType) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n    case TYPES.LENDELIM:\n      return subType || \"len_delim\";\n    case TYPES.FIXED32:\n      return \"fixed32\";\n    case TYPES.FIXED64:\n      return \"fixed64\";\n    default:\n      return \"unknown\";\n  }\n}\n","import JSBI from \"jsbi\";\nimport { bufferLeToBeHex, bufferToPrettyHex } from \"./hexUtils\";\n\n\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue });\n  }\n\n  result.push({ type: \"Float\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeFixed64(value) {\n\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue.toString() });\n\n\n  return result;\n}\n\n\n// this is also related\n\nexport function decodeVarintParts(value) {\n  const result = [];\n  const intVal = JSBI.BigInt(value);\n  result.push({  value: intVal.toString() });\n\n\n  return result;\n}\n\nexport function decodeStringOrBytes(value) {\n  if (!value.length) {\n    return { type: \"string|bytes\", value: \"\" };\n  }\n  const td = new TextDecoder(\"utf-8\", { fatal: true });\n  try {\n    return { type: \"string\", value: td.decode(value) };\n  } catch (e) {\n    return { type: \"bytes\", value: bufferToPrettyHex(value) };\n  }\n}\n\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}\n","import React from \"react\";\n\nimport { decodeProto, TYPES } from \"./protobufDecoder\";\nimport {\n\n\n  decodeStringOrBytes,\n  decodeVarintParts\n} from \"./protobufPartDecoder\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\n\n\n\nfunction ProtobufVarintPart(props) {\n  const { value } = props;\n  const decoded = decodeVarintParts(value);\n  // this is what we are looking for:\n  return decoded.map((d, i) => {\n    return i === 0 ? d.value : null;\n  }).filter(x => x);\n}\n\n\n\n\n\n\nfunction getProtobufPart(part) {\n  // eslint-disable-next-line\n  switch (part.type) {\n    case TYPES.VARINT:\n      return [<ProtobufVarintPart value={part.value} />];\n    case TYPES.LENDELIM:\n      // TODO: Support repeated field\n\n\n      let decoded = decodeProto(part.value);\n\n\n      if (part.value.length > 0 && decoded.leftOver.length === 0) {\n        return [<ProtobufDisplay value={decoded} />];\n      } else {\n        decoded = decodeStringOrBytes(part.value);\n        return \"\";\n      }\n\n\n  }\n}\n\nfunction ProtobufPart(props) {\n  const { part } = props;\n\n  const [contents] = getProtobufPart(part);\n\n\nreturn (\n  contents\n);\n}\n\nexport default ProtobufPart;\n","import React, { Fragment } from \"react\";\nimport ProtobufPart from \"./ProtobufPart\";\n\n\n\nfunction ProtobufDisplay(props) {\n  const { value } = props;\n\n  const parts = value.parts.map((part, i) => {\n  return i === 0 ? <ProtobufPart key={i} part={part} /> : null;\n}).filter(x => x);\n\n\n\nreturn (\n  <Fragment>\n    {parts}\n  </Fragment>\n);\n}\n\nexport default ProtobufDisplay;\n","import React, { Fragment, useState, useEffect } from \"react\";\n\nimport { useLocation } from 'react-router-dom';\nimport { parseInput } from \"./hexUtils\";\nimport \"./App.css\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\nimport { decodeProto } from \"./protobufDecoder\";\n\nfunction App() {\n\n  const [hexBuffer, setHexBuffer] = useState(\"\");\n  const location = useLocation();\n\n\n\n\n  useEffect(() => {\n    if (location.pathname !== '/') {\n      const newHex = decodeURI(location.pathname.substr(1));\n\n\n      // Parsing and decoding\n      const buffer = parseInput(newHex);\n\n      setHexBuffer(buffer);\n    }\n  }, [location.pathname]);\n\n\n  const result = hexBuffer ? (\n\n\n      <ProtobufDisplay value={decodeProto(hexBuffer)} />\n\n  ) : null;\n\n  return (\n    <Fragment>\n\n\n\n      {result}\n\n    </Fragment>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport App from \"./App\";\nimport \"semantic-ui-css/semantic.min.css\";\n\nReactDOM.render(\n  <Router>\n    <App />\n  </Router>,\n  document.getElementById(\"root\")\n);"],"sourceRoot":""}